import { existsSync, writeFileSync, readFileSync, cpSync, readdirSync, statSync, mkdirSync, rmSync } from 'node:fs';
import { join, posix, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { build } from 'esbuild';

const pkg = JSON.parse(readFileSync(new URL('./package.json', import.meta.url), 'utf-8'));
const name = '@openworkers/adapter-static';
const version = pkg.version;

/**
 * @typedef {Object} AdapterOptions
 * @property {string} [input] - Input directory (default: 'dist' or 'build')
 * @property {string} [out] - Output directory (default: 'dist-openworkers')
 * @property {'directory' | 'flat'} [mode] - Routing mode (default: auto-detect)
 * @property {string} [fallback] - SPA fallback file (e.g., '/index.html' or '/200.html')
 * @property {string[]} [immutable] - Glob patterns for immutable assets
 */

/**
 * Build static site for OpenWorkers
 * @param {AdapterOptions} options
 */
export async function adapt(options = {}) {
  const input = options.input ?? findInputDir();
  const out = options.out ?? 'dist-openworkers';
  const fallback = options.fallback ?? null;

  if (!existsSync(input)) {
    throw new Error(`Input directory not found: ${input}`);
  }

  // Clean and create output directories
  rmSync(out, { recursive: true, force: true });
  mkdirSync(out, { recursive: true });
  mkdirSync(join(out, 'assets'), { recursive: true });

  // Copy all files to assets/
  cpSync(input, join(out, 'assets'), { recursive: true });

  // Detect routing mode
  const mode = options.mode ?? detectMode(join(out, 'assets'));

  // Detect immutable patterns
  const immutable = options.immutable ?? detectImmutable(join(out, 'assets'));

  // Generate _routes.json manifest for edge router
  const allFiles = listFiles(join(out, 'assets'));
  const staticFiles = allFiles.filter((f) => !isImmutablePath(f, immutable));

  // Split HTML files and non-HTML files
  const htmlFiles = staticFiles.filter((f) => f.endsWith('.html'));
  const nonHtmlFiles = staticFiles.filter((f) => !f.endsWith('.html'));

  // Generate prerendered routes (HTML files without .html extension)
  const prerenderedRoutes = htmlFiles.map((f) => {
    const path = '/' + f.replace(/\.html$/, '');
    // Convert /index to / and /foo/index to /foo
    return path.replace(/\/index$/, '/');
  });

  const manifest = {
    mode,
    fallback,
    immutable,
    // Static: all files with their original names (including .html)
    static: staticFiles.map((f) => '/' + f),
    // Prerendered: HTML files without .html extension
    prerendered: prerenderedRoutes,
    functions: [],
    // If fallback is set, worker handles all unmatched routes (SPA mode)
    ssr: fallback ? ['/*'] : []
  };

  writeFileSync(join(out, '_routes.json'), JSON.stringify(manifest, null, 2));

  // Bundle worker with esbuild (use _routes.json for ROUTES alias)
  await build({
    entryPoints: [fileURLToPath(new URL('./files/worker.js', import.meta.url).href)],
    bundle: true,
    format: 'esm',
    platform: 'browser',
    outfile: resolve(out, '_worker.js'),
    alias: {
      ROUTES: resolve(out, '_routes.json')
    },
    minify: false,
    banner: {
      js: `// Generated by ${name} v${version}\n`
    }
  });

  console.log(`Built static site for OpenWorkers:`);
  console.log(`  Input: ${input}`);
  console.log(`  Output: ${out}`);
  console.log(`  Mode: ${mode}`);
  console.log(`  Files: ${allFiles.length}`);

  if (fallback) {
    console.log(`  SPA fallback: ${fallback}`);
  }
}

/**
 * Find input directory (dist or build)
 * @returns {string}
 */
function findInputDir() {
  if (existsSync('dist')) return 'dist';
  if (existsSync('build')) return 'build';
  if (existsSync('out')) return 'out';
  if (existsSync('public')) return 'public';

  throw new Error('Could not find input directory. Specify --input or create dist/build folder.');
}

/**
 * Detect routing mode based on file structure
 * @param {string} dir
 * @returns {'directory' | 'flat'}
 */
function detectMode(dir) {
  // Check if there are index.html files in subdirectories (directory mode)
  const files = listFiles(dir);
  const hasNestedIndex = files.some((f) => f.includes('/index.html') && f !== 'index.html');

  if (hasNestedIndex) {
    return 'directory';
  }

  // Check if there are .html files at root level (flat mode)
  const hasRootHtml = files.some((f) => !f.includes('/') && f.endsWith('.html') && f !== 'index.html');

  if (hasRootHtml) {
    return 'flat';
  }

  // Default to directory mode
  return 'directory';
}

/**
 * Detect immutable asset patterns
 * @param {string} dir
 * @returns {string[]}
 */
function detectImmutable(dir) {
  const patterns = [];

  // Common patterns for hashed assets
  const commonImmutable = [
    '_app/immutable', // SvelteKit
    'assets', // Vite
    '_next/static', // Next.js
    '_astro' // Astro
  ];

  for (const pattern of commonImmutable) {
    if (existsSync(join(dir, pattern))) {
      patterns.push(`/${pattern}/*`);
    }
  }

  return patterns;
}

/**
 * Check if a path matches immutable patterns
 * @param {string} filepath
 * @param {string[]} patterns
 * @returns {boolean}
 */
function isImmutablePath(filepath, patterns) {
  for (const pattern of patterns) {
    if (pattern.endsWith('/*')) {
      const prefix = pattern.slice(1, -2); // Remove leading / and trailing /*

      if (filepath.startsWith(prefix)) {
        return true;
      }
    }
  }

  return false;
}

/**
 * List all files in a directory recursively
 * @param {string} dir
 * @param {string} [base='']
 * @returns {string[]}
 */
function listFiles(dir, base = '') {
  const results = [];
  const entries = readdirSync(dir);

  for (const entry of entries) {
    const fullPath = join(dir, entry);
    const relativePath = base ? posix.join(base, entry) : entry;
    const stat = statSync(fullPath);

    if (stat.isDirectory()) {
      results.push(...listFiles(fullPath, relativePath));
    } else {
      results.push(relativePath);
    }
  }

  return results;
}

export default adapt;
